# A Digital Formant Synthesiser in Python

## Overview

This repository contains Python code to implement a digital formant synthesiser, in either a cascade (series) or parallel arrangement. The figures output can then be used to generate an audio signal.

## Requirements

**Python 3.9.10**.
**numpy** library is required.
**matplotlib** library is required to use __data_plots.py__ to generate signal plots (this file is used in the vowel example files).

## Example Usage

Run the Python files __a_synth.py__, __i_synth.py__, __u_synth.py__ to produce the digital signal of the vowel phonemes /a/, /i/ and /u/.

## Background of the Formant Synthesiser

Formant synthesis is a method of additive synthesis that generates speech using filters to simulate the resonances of the vocal tract. Such synthesisers are formed by connecting the resonator filters in either cascade or parallel configuration.

Both types of synthesis are based on Fant’s source-filter acoustic theory of speech production (1970)  - this theory describes the vocal tract as a time-invariant linear system so in the frequency domain it can be represented as a linear transfer function (Klatt, 1980). Speech sounds can then be reasonably modelled using concatenative processing of a source signal by the formant resonators which simulate the frequency, amplitude and bandwidth of a specific formant in human speech (Styger & Keller, 1995).

### Cascade Model vs Parallel Model

The cascade synthesiser model consists of discrete-time formant resonators connected in series. The input signal passes through the first resonator and the resulting output becomes the input to the following resonator and so on.

The parallel synthesiser connects discrete-time formant resonators using parallel connections, so the input signal enters the parallel branches of the model simultaneously. An amplitude control precedes each resonator and controls the individual relative amplitude of the resultant formant peak.

## Documentation

### filter.py

The filter classes represent the various types of filters available to use in either a Cascade or Parallel filter-bank that comprises a formant synthesiser. All filter objects must be initialised with relevant input values and constants for use in the object methods.

Each class is initialised with the variable values needed to calculate the transfer functions for the specified type of discrete filter.
Resonator

#### Resonator

The Resonator class defines a formant resonator, this simulates a resonance of the vocal tract. An instance of this class is initialised with the formant frequency  , formant bandwidth   and sampling frequency.

#### PreEmphasis

The PreEmphasis class defines a pre-emphasis filter. An instance of this class is initialised with a cut-off frequency   (with a default value of 640 Hz) and the sampling frequency.

#### Differentiator

The Differentiator class defines a differentiator. An instance of this class is initialised with the cut-off frequency   and the sampling frequency.

### filter_bank.py

The filter-bank classes represent the two types of formant synthesisers available. They can be initialised with any number of filters or Cascade filter-banks. The amplitude and phase response, as well as the difference equation outputs of each filter, are combined within class methods, to provide the final discrete output for a filter-bank.

#### Cascade

A Cascade object can be initialised using one or more filters or groups of filters.

#### Parallel

A Parallel object can be initialised using one or more filters – this includes groups of filters (such as a filter-bank object) which allows for the combined response of filters in cascade to be used in parallel configurations (to create spectral shaping filters for example).

### Class Methods

Three methods are defined for all filter classes and all filter-bank classes.

#### getAmpResponse

This method uses the discrete amplitude response equation for the relevant filter or filter-bank type, to calculate and return two arrays – the frequency range and corresponding amplitude responses.

#### getPhaseResponse

This method uses the discrete phase response equation for the relevant filter type or filter-bank type, to calculate and return two arrays – the frequency range and corresponding phase responses.

#### generateOutput

This method uses the discrete time-domain difference equation for the relevant filter type or filter-bank type, to calculate and return two arrays – the time points and corresponding sampled signal output value. The source signal is generated by a standalone filter or the first filter in a filter-bank from the function generateOutput (which calculates the output values; see Class Methods). It takes the signal length in seconds as an argument.

### data_plots.py

Contains methods to plot the amplitude and phase response and waveform output visualizations.
